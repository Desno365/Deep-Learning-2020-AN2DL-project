import os
import json
import numpy as np
from PIL import Image


def rle_decode(rle, shape):
    s = rle.split()
    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]
    starts -= 1
    ends = starts + lengths
    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)
    for lo, hi in zip(starts, ends):
        img[lo:hi] = 1
    return img.reshape(shape)


if __name__ == "__main__":

    # Just for completeness, here we show how the rle encoded mask
    # is transformed back to a numpy array

    # Read the submission.json file generated by the
    # 'prepare_submission.py' script
    with open('./predictions/submission.json', 'r') as f:
        submission_dict = json.load(f)

    img_name = 'arr_mask_example'
    img_shape = submission_dict[img_name]['shape']

    rle_encoded_crop = submission_dict[img_name]['segmentation']['crop']
    rle_encoded_weed = submission_dict[img_name]['segmentation']['weed']

    # Reconstruct crop and weed binary masks
    crop_mask = rle_decode(rle_encoded_crop, shape=img_shape)
    weed_mask = rle_decode(rle_encoded_weed, shape=img_shape)

    # Reconstruct original mask
    # weed_mask * 2 allows to convert ones into target 2 (weed label)
    reconstructed_mask = crop_mask + (weed_mask * 2)

    # Check that the RLE decoded mask is the same of the original mask
    # before the RLE encoding
    original_mask = np.load('./predictions/arr_mask_example.npy')

    np.testing.assert_allclose(original_mask, reconstructed_mask)

    # Just for visualisation purposes, save RGB reconstructed mask
    # Use again the dictionary in 'RGBtoTarget.txt'.
    reconstructed_rgb_arr = np.zeros(shape=img_shape + [3])
    reconstructed_rgb_arr[reconstructed_mask == 1] = [255, 255, 255]
    reconstructed_rgb_arr[reconstructed_mask == 2] = [216, 67, 82]

    reconstructed_rgb_img = Image.fromarray(
        np.uint8(reconstructed_rgb_arr))
    reconstructed_rgb_img.save('./predictions/rle_decoded_rgb_mask.png')

    # Please notice that the 'unknown' class corresponding to the
    # RGB value [216, 124, 18] is not considered for the evaluation
    # and thus does not appear in the reconstructed mask.
